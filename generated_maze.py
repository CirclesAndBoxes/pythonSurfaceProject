# Generated by Chat-GPT 3.5

import random

def generate_maze(rows, cols):
    # Create a grid filled with walls
    maze = [[1] * (2 * cols - 0) for _ in range(2 * rows - 0)]

    # Initialize variables
    stack = [(5, 3)]  # Start the stack with the entrance
    visited = set([(5, 3)])

    # Define directions (up, down, left, right)
    directions = [(-2, 0), (2, 0), (0, -2), (0, 2)]

    while stack:
        current_cell = stack[-1]

        # Get neighbors
        neighbors = [(current_cell[0] + d[0], current_cell[1] + d[1]) for d in directions]

        # Filter valid neighbors
        valid_neighbors = [neighbor for neighbor in neighbors if 0 < neighbor[0] < 2 * rows and 0 < neighbor[1] < 2 * cols and neighbor not in visited]

        if valid_neighbors:
            # Choose a random valid neighbor
            next_cell = random.choice(valid_neighbors)

            # Break the walls between the current cell and the chosen neighbor
            maze[(current_cell[0] + next_cell[0]) // 2][(current_cell[1] + next_cell[1]) // 2] = 0
            maze[next_cell[0]][next_cell[1]] = 0

            # Mark the chosen neighbor as visited
            visited.add(next_cell)

            # Move to the chosen neighbor
            stack.append(next_cell)
        else:
            # Backtrack if no valid neighbors
            stack.pop()

    maze.pop(0)
    for row in maze:
        row.pop(0)

    # Set entrance and exit
    maze[6][3] = 0
    maze[0][3] = 0

    return maze

def print_maze(maze):
    for row in maze:
        print(''.join(str(row)))

if __name__ == "__main__":
    rows, cols = 4, 4
    maze = generate_maze(rows, cols)
    print_maze(maze)
    print(maze)
    print(type(maze))
    print(type([[1, 0, 1, 2, 1, 1, 0],
        [0, 0, 0, 0, 1, 0, 0],
        [0, 1, 1, 1, 1, 0, 1],
        [0, 0, 0, 0, 0, 0, 1],
        [0, 1, 1, 1, 1, 0, 1],
        [1, 0, 0, 0, 0, 0, 1],
        [0, 0, 1, 0, 1, 1, 1]]))
    temp_array = [0, 1]
    new_array = temp_array
    temp_array = [0, 2]
    print(temp_array,new_array)
